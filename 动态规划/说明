求解一个大问题的最优解，通常通过其子问题的最优解组合得到，通常为了避免递归中的重复子问题现象，
如f（n）=f（n-1）*f(n-2),使用递归的话，会有重复的子问题，因此，使用自下而上的方法，先求解小问题最优，
再往上求解大问题的最优，如青蛙跳台阶，剪绳子（offer14），数字翻译成字符串（offer46），
礼物的最大值（offer47）不同路径（mn矩阵，00到mn，有多少种走法），
最小路径和（动态规划，初始化第一行和第一列，dp00初始值为grid00的初始值，然后进行更新），
不同的二叉搜索树（动态规划，n为根节点，当i为根节点时，其左子树节点个数为[1,2,3,...,i-1]，
右子树节点个数为[i+1,i+2,...n]，所以当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，即f(i) = G(i-1)*G(n-i)
,上面两式可得:G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)），最大正方形（在一个由 0 和 1 组成的二维矩阵内，
找到只包含 1 的最大正方形，并返回其面积，dp数组用于存放最大的边长，dp[i][j]=min(dp[i-1][j],dp[i-1[j-1],dp[i][j-1])
）;完全平方数(当前正整数n的结果对应于n去掉一个完全平方数之后的子问题结果加一，但是去掉哪一个完全平方数才能达到最佳结果
呢，这就需要我们自己去进行一个遍历，然后取最小的值即可。dp[i] = min(dp[i], dp[i-j*j]+1)，
最长上升子序列（动态规划，dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)，dp[i]表示位置前的最长序列，
i为第一层遍历，j为i之前的遍历）